{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-01-05T00:42:48.990916+00:00",
  "repo": "mwelzl/draft-iccrg-pacing",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOL2DqS86HvkKM",
      "title": "Mac OS(es) description",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/issues/1",
      "state": "OPEN",
      "author": "mwelzl",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "todo Vidhi",
      "createdAt": "2024-05-03T10:32:25Z",
      "updatedAt": "2024-10-12T10:03:18Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "body": "We have that now, but it could be more detailed...",
          "createdAt": "2024-10-12T10:03:17Z",
          "updatedAt": "2024-10-12T10:03:17Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOL2DqS86HvkRM",
      "title": "QUIC BBR description",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/issues/2",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "todo Wes",
      "createdAt": "2024-05-03T10:32:42Z",
      "updatedAt": "2024-07-03T14:22:57Z",
      "closedAt": "2024-07-03T14:22:57Z",
      "comments": []
    },
    {
      "number": 3,
      "id": "I_kwDOL2DqS86Hvkgo",
      "title": "General pacing considerations",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/issues/3",
      "state": "OPEN",
      "author": "mwelzl",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "We could have a list of pro's and con's of pacing (yes there are also con's).",
      "createdAt": "2024-05-03T10:33:22Z",
      "updatedAt": "2024-11-18T12:52:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "body": "Some pro's of pacing:\r\n\r\n- less likely to provoke spontaneous loss from bursts\r\n- less likely to cause sudden, ephemeral delay increase\r\n- more likely to really saturate the available capacity, especially when queues are short\r\n\r\nSome con's of pacing:\r\n\r\n- more sustained delay growth\r\n- slight (miniscule, perhaps negligible) delays due to delaying packets\r\n- *perhaps* some more from [this old well-known paper](https://homes.cs.washington.edu/~tom/pubs/pacing.pdf) - but the last time I looked, the negative effects seemed to be tied to the combination of adding pacing and using an old TCP version. I don't remember if this is the case for *all* problems identified in this paper, though.",
          "createdAt": "2024-05-06T14:06:32Z",
          "updatedAt": "2024-05-06T14:06:32Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "body": "Just to report this here, in emails we agreed that yes, this should be a draft on pacing in general, and con's shouldn't be phrased as \"con's\" but rather \"consequences\" which aren't necessarily all bad.",
          "createdAt": "2024-07-01T11:10:41Z",
          "updatedAt": "2024-07-01T11:10:41Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "body": "So we don't forget, a to-do item: @wesley-eddy suggested to also discuss dynamics with AQM.",
          "createdAt": "2024-07-02T11:02:59Z",
          "updatedAt": "2024-07-02T11:02:59Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "body": "Probably, the need for fine-grain timers should also be a \"general consideration\" - this will explain the reader why implementations diverge (e.g., Linux limiting itself to 1ms granularity).",
          "createdAt": "2024-07-04T08:53:02Z",
          "updatedAt": "2024-07-04T08:53:02Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "body": "Generally, this issue is related to Issue #17.\r\n\r\nFrom Eduard Vasilenko:\r\n\r\nWhen I explained pacing\u2019s importance, I stressed that the biggest problem is a bump of the high-speed path into the low-speed access (5G or WiFi).\r\nSomething like: \u201cExample:\r\nIf a 15Mbps client is 20ms away. Then CUBIC on the server could burst up to 77kB (BDP) of data, it is a 5.9us burst on the 100GE link.\r\nThat is an additional 20ms burst for the client\u2019s shaper on BRAS or wireless AP that may be already loaded close to the maximum.\u201d\r\n<image005.png>\r\n\r\nIMHO: this fact is not stressed well enough in section 3.\r\nThe story of how 5.9us becomes 20ms is very important story.",
          "createdAt": "2024-11-18T12:52:07Z",
          "updatedAt": "2024-11-18T12:52:07Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOL2DqS86OeTt1",
      "title": "Linux SRTT calculation check",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/issues/9",
      "state": "OPEN",
      "author": "mwelzl",
      "authorAssociation": "OWNER",
      "assignees": [
        "mwelzl"
      ],
      "labels": [],
      "body": "The Linux TCP text currently says: SRTT is the smoothed round-trip time [[RFC6298](https://mwelzl.github.io/draft-iccrg-pacing/draft-welzl-iccrg-pacing.html#RFC6298)] [TODO check: Linux calculates SRTT different from the standard, though RFC 6298 relaxes the rules, so maybe it's ok?]\r\n\r\nIndeed, that check should be done - if it's \"not okay\", there should be some text explaining how the Linux SRTT calculation works.",
      "createdAt": "2024-07-04T08:50:31Z",
      "updatedAt": "2024-10-30T14:54:40Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "body": "It's not RFC 6298 that relaxes the rules, it's [RFC 8961](https://www.rfc-editor.org/rfc/rfc8961.html).",
          "createdAt": "2024-10-17T13:53:11Z",
          "updatedAt": "2024-10-17T13:53:11Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "body": "First, the code:\r\n\r\nHere is an analysis of the RTT estimation in Linux, as found at:\r\nhttps://elixir.bootlin.com/linux/v6.11.5/source/net/ipv4/tcp_input.c#L869\r\n\r\nThis is about the function tcp_rtt_estimator, line 869 ff. in net/ipv4/tcp_input.c, kernel v6.11.5. This function gets a new rtt sample, called mrtt_us.\r\n\r\n\r\nCASE 1: THERE IS A PREVIOUS SAMPLE:\r\n\r\nThe stored srtt_us is left-shifted by 3 bits (comment: \"/ smoothed round trip time << 3 in usecs /\"); thus the comment \"m is now error in rtt est\", in line 892, next to:\r\nm -= (srtt >> 3);\r\nis correct, i.e. m now really is the difference between srtt and the latest sample (mrtt_us).\r\n\r\nLet's look at the next line, srtt += m, with the comment:\r\n/* rtt = 7/8 rtt + 1/8 new */\r\n\r\nNote that the value of the \"srtt\" variable is actually the srtt << 3, i.e. times 8. So, using \"SRTT\" to represent srtt in the common meaning and RTT to represent the new RTT sample, this line translates into:\r\n\r\nSRTT = SRTT * 8 + (RTT-SRTT)\r\nwhich really is the same as:\r\nSRTT = SRTT * 7 + RTT\r\n\r\n... which is what the comment says, with the exception that the resulting SRTT value is 8 times too large (i.e., left-shifted by 3 bits), but that's how this value is stored in the end.\r\n\r\nNext, \"mdev\" and \"rttvar\" are updated... which are meaningful for RTO calculation but not for the SRTT directly. \r\n\r\n\r\nCASE 2: THERE IS NO PREVIOUS SAMPLE  (INIT.):\r\n\r\nSRTT is set to RTT (the measured time). In the code, really, it is set to \"m << 3\": before this, m is initialized to be the same as mrtt_us, and it's left-shifted by 3 bits because this is how the SRTT is really stored (srtt_us).\r\n\r\n\r\nGenerally (in line 934), the code also sets a minimum value for SRTT, which is \"1\": this really represents 1/3 microseconds, I believe.\r\n",
          "createdAt": "2024-10-30T14:49:53Z",
          "updatedAt": "2024-10-30T14:53:42Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "body": "The short version of the above:\r\nInitially, SRTT = RTT  (\"RTT\" is the new sample).\r\nThen, to update, SRTT = 7/8 * SRTT + 1/8 * RTT.",
          "createdAt": "2024-10-30T14:54:18Z",
          "updatedAt": "2024-10-30T14:54:40Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOL2DqS86Z8dQE",
      "title": "Time scales (or: application layer)",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/issues/11",
      "state": "OPEN",
      "author": "mwelzl",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The \"Sammy\" paper:  https://dl.acm.org/doi/10.1145/3603269.3604839   paces at a larger time scale - avoiding to transmit video data as a bulk but instead spreading it out. This can be done with or without RTT-timescale pacing underneath, and should be discussed as a separate thing IMO.\r\n\r\nPerhaps the right angle is to talk about different time scales, or it is about being at the application layer (because this is really application payload specific).",
      "createdAt": "2024-10-12T10:07:28Z",
      "updatedAt": "2024-11-08T10:01:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "body": "A text donation from Ingemar Johansson:\r\n\r\n> Frame based transmission, for instance based on output from video coders possess the property that video frames are typically generated at regular intervals. For example a video coder that encodes video at 50 frames per second, outputs  a frame every 20ms. This frame is typically split up in MTU sized packets. Video coding typically also encodes frames of varying size, depending on the complexity of the input signal.  \r\nThis has the consequence that the packet pacing cannot be tuned to match the nominal bitrate, as this would mean that large video frames are unnecessarily delay on the sender side.\r\nSCReAM (https://datatracker.ietf.org/doc/draft-johansson-ccwg-rfc8298bis-screamv2/ ) as an example paces, packets at a 50% higher rate than the nominal bitrate. This has the effect that an average video frame in the example above is transmitted in 20/1.5 = 13.3ms. This reduces the risk that video frames are delayed unnecesarily  other than when the video frame is unusually large.",
          "createdAt": "2024-10-24T19:52:04Z",
          "updatedAt": "2024-10-24T19:52:04Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "body": "From Grenville Armitage, this is a different way of looking at \"Sammy\" - probably a better phrasing, not about time scales:\r\n\r\n>Sammy makes target upper-bound rate selection on a per-video-chunk basis, and then relies on underlying TCP packet level pacing to instantiate the per-chunk rate-limit target. So, decoupling the rate target selection logic (also referred to as \"application informed pacing\" in the paper) from the instantiation of that upper-bound (in this specific case relying on FreeBSD's HPTS subsystem giving us TCP packet granularity pacing, but of course could be any other subsystem achieving similar on-the-wire outcomes).",
          "createdAt": "2024-10-25T23:15:05Z",
          "updatedAt": "2024-11-08T10:01:59Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOL2DqS86Z8dZN",
      "title": "FreeBSD",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/issues/12",
      "state": "OPEN",
      "author": "mwelzl",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Michael Tuexen has volunteered to write text.",
      "createdAt": "2024-10-12T10:09:01Z",
      "updatedAt": "2024-10-25T23:16:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "body": "Update: we have some text now. More to come :-)",
          "createdAt": "2024-10-21T10:12:42Z",
          "updatedAt": "2024-10-21T10:12:42Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOL2DqS86bpLmu",
      "title": "Initial RTT estimate in 5G access: input for section 3",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/issues/16",
      "state": "OPEN",
      "author": "mwelzl",
      "authorAssociation": "OWNER",
      "assignees": [
        "mwelzl"
      ],
      "labels": [],
      "body": "See this email from Ingemar Johannson:\r\nhttps://mailarchive.ietf.org/arch/msg/iccrg/8LHZwBITPSnJc5akwsAGqPn3zGM/",
      "createdAt": "2024-10-24T11:21:34Z",
      "updatedAt": "2024-10-24T11:21:34Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 17,
      "id": "I_kwDOL2DqS86dnKEO",
      "title": "Acknowledge disadvantages of pacing over wireless",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/issues/17",
      "state": "OPEN",
      "author": "mwelzl",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "See the panel discussion @ ICCRG in IETF 121. Pacing works against frame aggregation (or: you pace, and then your packets get aggregated by the hardware below anyway). As Matt Mathis said in the conversation, generally, hardware can work better with larger blocks of data, at the cost of jitter for everyone else.",
      "createdAt": "2024-11-08T14:57:46Z",
      "updatedAt": "2024-11-21T07:52:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "body": "From Eduard Vasilenko:\r\n\r\nPacing is very useful in the majority of situations. But there are some corner cases when proper burstiness is very valuable:\r\n\u201cPudica: Toward Near-Zero Queuing Delay in Congestion Control for Cloud Gaming\u201d\r\nBursts are created intentionally (something like +25%), then it is possible to see how fast is the drain, then it is possible to estimate the link load that is much below 100% on average!\r\nIf WiFi is transferring big packages (A-MSDU) then the overhead is much smaller, and it is possible to get the better goodput: [Improving Performance of QUIC in WiFi](https://upcommons.upc.edu/bitstream/handle/2117/172208/main.pdf)\r\n \r\nHence, it is possible to comment in the draft that pacing is not always a good goal. There are opposite corner cases.",
          "createdAt": "2024-11-18T11:59:49Z",
          "updatedAt": "2024-11-18T11:59:49Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "body": "This is also worth another look:  https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9772053&tag=1  (too much time has passed since I last read this)",
          "createdAt": "2024-11-18T12:04:11Z",
          "updatedAt": "2024-11-18T12:04:11Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "pacing rate is calculated based on link bandwidth, in units of bytes/sec. Aggregation can still be achieved by allowing a min burst size per send call and this burst can be specified in units of time, for example Prague implementations currently use 250us. And then corresponding burst size can be calculated by multiplying pacing rate * burst (eg. burst size for 100MBps link would be (100MBps * .000250). This should allow transferring big AMPDUs at WiFi layer.\r\n\r\nNot pacing at all is not ideal for any type of traffic whether it is gaming or video. I think pacing is a good goal universally, its just how it is done can be different from use case to use case. Some apps might do pacing at 100%, some might do at a lower rate and some might do at a higher rate. Also, a single app might choose to do pacing at different rates at different times.\r\n\r\nRegarding, lower layer aggregation, I agree that can be counter productive to pacing. Product companies should invest time to reduce queuing and hence aggregation in lower layers. Nokia with their L4S capable WiFi has shown that low queuing and the correct amount of aggregation can be achieved in WiFi.\r\n",
          "createdAt": "2024-11-20T23:49:05Z",
          "updatedAt": "2024-11-20T23:49:05Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "body": "@goelvidhi I agree with all you say here.\r\n\r\nI believe one major take-away is that this all depends on the targeted transmission rate: the faster I need to go, the more bursty I should be, up to a limit (and indeed, using time as a limit as in your Prague example will achieve that).\r\n\r\nWhy should I even care about frame aggregation for a VoIP application low-rate low-latency signaling traffic of a game?\r\n\r\nNote though that \"high rate\" doesn't mean \"large file transfer\" only - e.g. the QUIC paper mentioned above has a plot showing significant reduction in PLT from being more bursty. A static web transfer is limited by the Flow Completion Time (FCT), i.e. we want as high throughput as possible for this application and don't actually care about queuing. Interactive traffic is very different.\r\n\r\nSo, it all depends on the type of application - but, luckily, a simple time-based rule such as the Prague one you mention will probably do the right thing automatically, under all circumstances.",
          "createdAt": "2024-11-21T07:52:58Z",
          "updatedAt": "2024-11-21T07:52:58Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 4,
      "id": "PR_kwDOL2DqS85z8UcE",
      "title": "First edit",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/pull/4",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hello, I added some text to the abstract and introduction. I only covered the advantages of Pacing listed in #3. I don't think we need to mention the cons as I don't really see them as important but we can discuss this.\r\n",
      "createdAt": "2024-06-29T01:26:51Z",
      "updatedAt": "2024-07-01T07:26:06Z",
      "baseRepository": "mwelzl/draft-iccrg-pacing",
      "baseRefName": "main",
      "baseRefOid": "e7e8efec32d8bf990137f1fcd10ebc26924149c1",
      "headRepository": "goelvidhi/draft-iccrg-pacing",
      "headRefName": "first-edit",
      "headRefOid": "5e1ebed27853078626235d929cacec909e232230",
      "closedAt": "2024-07-01T07:26:05Z",
      "mergedAt": "2024-07-01T07:26:05Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "c652ee7bc237d8b86aa1a941320e158722e41aca"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOL2DqS86AHpQc",
          "commit": {
            "abbreviatedOid": "e436a53"
          },
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "Many thanks for this!  Good progress!",
          "createdAt": "2024-06-29T09:56:16Z",
          "updatedAt": "2024-06-29T10:18:45Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Thanks, I think this is generally a better abstract!  Just some suggestions:\r\n\r\n```suggestion\r\nApplications or congestion control mechanisms can produce bursty traffic which can cause unnecessary queuing and packet loss. To reduce the burstiness of traffic, the concept of evenly spacing out the traffic from a data sender over a round-trip time known as Pacing has been used in many transport protocol implementations. This document gives an overview of Pacing and how some known Pacing implementations work.\r\n```\r\n\r\nHere's why I make these suggestions:\r\n- Congestion control mechanisms \"and applications\" because, well, that's the truth. If I write an app over UDP, with or without CC, my traffic can be bursty or not.\r\n- I didn't understand the point of \"when used alone in transport protocols\", so I suggest removing that.\r\n- I suggest removing the \"higher\" comparison in the first sentence because it makes me ask \"higher than what?\".\r\n- The \"such\" in \"such traffic\" also makes me want to ask \"what traffic are you talking about\"?  Congestion controlled traffic only?  Anyway \"such\" just seems unnecessary to me here.\r\n- \"also known as Pacing\" - I think it's just known as Pacing, that's the word for it. No need for \"also\".",
              "createdAt": "2024-06-29T09:56:16Z",
              "updatedAt": "2024-06-29T10:18:45Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nRFCs describing congestion control generally refer to congestion window (cwnd) as an upper limit for the number of unacknowledged packets a sender is allowed to emit. This limits the sender's transmission rate at the granularity of a round-trip time (RTT). If the sender transmits the entire cwnd sized data in an instant, this can results in unnecessarily high queuing and eventually packet losses at the bottleneck. Such consequences are detrimental to users' applications in terms of both responsiveness and goodput. To solve this problem, the concept of pacing was introduced. Pacing allows to send the same cwnd sized data but spread it across a round-trip time more evenly.\r\n```\r\n\r\n\"more evenly\" (across the rtt) is important, IMO, because at least Linux in slow start does not necessarily spread them \"across the RTT evenly\" for several rounds  (does Apple?  Note that cwnd changes when ACKs come - so the basic Linux logic of delaying with cwnd/rtt does *not* produce an even spread across the RTT when cwnd changes significantly with arriving ACKs).\r\n\r\nI suggest removing the \"resulting in a more even use\" because, first, \"a more even use\" seems imprecise, and second, the next paragraph goes into more details on the benefits anyway.",
              "createdAt": "2024-06-29T10:07:12Z",
              "updatedAt": "2024-06-29T10:18:45Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nCongestion control specifications always allow to send less than the cwnd, or temporarily emit packets at a lower rate. Accordingly, it is in line with these specifications to pace packets. Pacing is known to have advantages -- if some packets arrive at a bottleneck as a burst (all packets being back-to-back), loss can be more likely to happen than in a case where there are time gaps between packets (e.g., when they are spread out over the RTT). It also means that pacing is less likely to cause any sudden, ephemeral increases in queuing delay. Since keeping the queues short reduces packet losses, pacing is more likely to yield higher goodput by reducing the time lost in loss recovery.\r\n```",
              "createdAt": "2024-06-29T10:15:37Z",
              "updatedAt": "2024-06-29T10:18:45Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n**TEMPORARY NOTE - TO BE REMOVED:** This description is based on the longer Linux pacing analysis text that is currently available at: [https://docs.google.com/document/d/1h5hN9isFjT76YjaCphHZdW9LCRYqV4y3GKwRKxgqEO0/edit?usp=sharing](https://docs.google.com/document/d/1h5hN9isFjT76YjaCphHZdW9LCRYqV4y3GKwRKxgqEO0/edit?usp=sharing)  - comments or corrections are very welcome!\r\n```\r\n\r\nUpdating the URL because I have a slightly newer, improved version there.",
              "createdAt": "2024-06-29T10:18:24Z",
              "updatedAt": "2024-06-29T10:18:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL2DqS86AKj6i",
          "commit": {
            "abbreviatedOid": "e436a53"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-01T01:14:34Z",
          "updatedAt": "2024-07-01T01:14:34Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Agree with all the suggestions.",
              "createdAt": "2024-07-01T01:14:34Z",
              "updatedAt": "2024-07-01T01:14:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL2DqS86AKkWA",
          "commit": {
            "abbreviatedOid": "e436a53"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-01T01:18:22Z",
          "updatedAt": "2024-07-01T01:18:22Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "You are right, at least in slow start, the distribution across a RTT is not perfectly even with rate being 2*cwnd/RTT. So, I agree with your suggested changes.",
              "createdAt": "2024-07-01T01:18:22Z",
              "updatedAt": "2024-07-01T01:18:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL2DqS86AL9Ms",
          "commit": {
            "abbreviatedOid": "b3c7cc5"
          },
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-01T07:23:50Z",
          "updatedAt": "2024-07-01T07:23:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOL2DqS850EE2u",
      "title": "changing the heading structure, and some very minor edits",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/pull/5",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Hm. Maybe it was a mistake to create a PR just for this minor thing: I'll merge it right away, because I need the new structure for the next PR.",
      "createdAt": "2024-07-01T12:22:51Z",
      "updatedAt": "2024-07-01T12:23:23Z",
      "baseRepository": "mwelzl/draft-iccrg-pacing",
      "baseRefName": "main",
      "baseRefOid": "7a3183fa761168023c5945a4778fcf517e118fbb",
      "headRepository": "mwelzl/draft-iccrg-pacing",
      "headRefName": "mw-restructure",
      "headRefOid": "aeed3b9e337ee5aba29403d6cec14b97738aa164",
      "closedAt": "2024-07-01T12:23:23Z",
      "mergedAt": "2024-07-01T12:23:23Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "ac9734c3e9a4043d1e6391c0984f2781fa09c2df"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 6,
      "id": "PR_kwDOL2DqS850Fz9U",
      "title": "General pacing considerations",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/pull/6",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-01T16:05:24Z",
      "updatedAt": "2024-07-03T14:18:29Z",
      "baseRepository": "mwelzl/draft-iccrg-pacing",
      "baseRefName": "main",
      "baseRefOid": "697177a6164c898352685cc9d4f2fb351c95b5f2",
      "headRepository": "mwelzl/draft-iccrg-pacing",
      "headRefName": "mw-consequences",
      "headRefOid": "0ea2114709278c5230da23300abcb492b4d8d5bc",
      "closedAt": "2024-07-03T14:18:28Z",
      "mergedAt": "2024-07-03T14:18:28Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "a7bd13a41b6d86ad2ba09088471c6fe887454d9a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOL2DqS86AQrcg",
          "commit": {
            "abbreviatedOid": "4316e25"
          },
          "author": "wesley-eddy",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-01T17:06:14Z",
          "updatedAt": "2024-07-01T17:11:43Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Is it also productive later to also consider the case of AQM?  I think we would agree that pacing has benefits when paired with AQM as well, not just in the FIFO case.",
              "createdAt": "2024-07-01T17:06:14Z",
              "updatedAt": "2024-07-01T17:11:43Z"
            },
            {
              "originalPosition": 19,
              "body": "Further, should we say that pacing gives more time for the growth of the queue to be detected by the transport (e.g. within a delay signal, or in the case of AQM via ECN) prior to it resulting in necessary loss, in comparison to the non-pacing case?",
              "createdAt": "2024-07-01T17:10:04Z",
              "updatedAt": "2024-07-01T17:11:43Z"
            },
            {
              "originalPosition": 36,
              "body": "Is an RTT estimate also available via a route cache from a recent connection?",
              "createdAt": "2024-07-01T17:11:28Z",
              "updatedAt": "2024-07-01T17:11:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL2DqS86ASSKS",
          "commit": {
            "abbreviatedOid": "4316e25"
          },
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-01T21:28:17Z",
          "updatedAt": "2024-07-01T21:28:18Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "HOW COULD I FORGET!  This was the whole point I wanted to get at - a plug for RFC 9040  :-)   Will do!",
              "createdAt": "2024-07-01T21:28:17Z",
              "updatedAt": "2024-07-01T21:28:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL2DqS86ASSrj",
          "commit": {
            "abbreviatedOid": "4316e25"
          },
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-01T21:30:11Z",
          "updatedAt": "2024-07-01T21:30:12Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "AQM is more random, and this is me paraphrasing my model, which is based upon a FIFO queue. I agree that saying something about AQM would be good, but... perhaps further down, as a separate subsection?",
              "createdAt": "2024-07-01T21:30:12Z",
              "updatedAt": "2024-07-01T21:30:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL2DqS86ASTfr",
          "commit": {
            "abbreviatedOid": "4316e25"
          },
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-01T21:33:28Z",
          "updatedAt": "2024-07-01T21:33:29Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Hm, does this really only play out positively? It may depend on the AQM...  for creating a more sustained queue growth, a paced flow may end up being \"punished\" earlier? Or causing punishment for all flows earlier?\r\n\r\nOverall I personally think that everything to do with pacing is good, because it makes the behavior more in line with the expectations of a CC algorithm; but in specific scenarios, given how algorithms behave today, bad things MAY happen, and I'd like to avoid a confusion... so let's be a bit cautious with what we say.  The stuff I do say here, based on FIFO and a single flow, I'm very sure about.",
              "createdAt": "2024-07-01T21:33:29Z",
              "updatedAt": "2024-07-01T21:33:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL2DqS86AW23w",
          "commit": {
            "abbreviatedOid": "4316e25"
          },
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-02T11:04:17Z",
          "updatedAt": "2024-07-02T11:04:17Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I added discussing dynamics with AQM as a todo item in issue #3 ",
              "createdAt": "2024-07-02T11:04:17Z",
              "updatedAt": "2024-07-02T11:04:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL2DqS86Aijve",
          "commit": {
            "abbreviatedOid": "4316e25"
          },
          "author": "wesley-eddy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-03T14:00:28Z",
          "updatedAt": "2024-07-03T14:00:29Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Agreed!",
              "createdAt": "2024-07-03T14:00:29Z",
              "updatedAt": "2024-07-03T14:00:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDOL2DqS850F2VU",
      "title": "security considerations",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/pull/7",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-01T16:11:09Z",
      "updatedAt": "2024-07-03T14:19:24Z",
      "baseRepository": "mwelzl/draft-iccrg-pacing",
      "baseRefName": "main",
      "baseRefOid": "697177a6164c898352685cc9d4f2fb351c95b5f2",
      "headRepository": "mwelzl/draft-iccrg-pacing",
      "headRefName": "mw-security",
      "headRefOid": "3c5ceccc284a58aa17f6fda42b568bb0d926033b",
      "closedAt": "2024-07-03T14:19:24Z",
      "mergedAt": "2024-07-03T14:19:24Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "3387690bcd4c6f276d1dfaa785cb73b00926c44f"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "body": "I hope Gorry won't mind that I almost literally lifted his text for this section off one of our common drafts...",
          "createdAt": "2024-07-03T14:19:18Z",
          "updatedAt": "2024-07-03T14:19:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOL2DqS86AijRH",
          "commit": {
            "abbreviatedOid": "3c5cecc"
          },
          "author": "wesley-eddy",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-03T13:59:43Z",
          "updatedAt": "2024-07-03T13:59:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 8,
      "id": "PR_kwDOL2DqS850IcNd",
      "title": "initial QUIC BBR text",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/pull/8",
      "state": "MERGED",
      "author": "wesley-eddy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Initial content for QUIC BBR section, and other small suggested edits.",
      "createdAt": "2024-07-02T00:56:18Z",
      "updatedAt": "2024-07-03T14:22:57Z",
      "baseRepository": "mwelzl/draft-iccrg-pacing",
      "baseRefName": "main",
      "baseRefOid": "697177a6164c898352685cc9d4f2fb351c95b5f2",
      "headRepository": "mwelzl/draft-iccrg-pacing",
      "headRefName": "wes-edits",
      "headRefOid": "cbe957ecfc23ff8daaa25096c8dfc29cc3c8a4b3",
      "closedAt": "2024-07-03T14:22:57Z",
      "mergedAt": "2024-07-03T14:22:57Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "65f0f2e87e782a45ec866d7c7fef5e1058e67f7f"
      },
      "comments": [
        {
          "author": "wesley-eddy",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the edits Michael!  I think I've responded to your other comments too.",
          "createdAt": "2024-07-03T13:58:26Z",
          "updatedAt": "2024-07-03T13:58:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOL2DqS86AWxoA",
          "commit": {
            "abbreviatedOid": "2e71759"
          },
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "A few minor suggestions - but this is a great PR, thanks!  I learned some pretty interesting things here, I wasn't aware of the token-based schemes (they make sense of course, but I just hadn't seen them before)",
          "createdAt": "2024-07-02T10:53:08Z",
          "updatedAt": "2024-07-02T11:00:54Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "```suggestion\r\nPacing capability is expected in QUIC senders.  While standard QUIC congestion control {{RFC9002}} is based on TCP Reno, which is not defined to include pacing (but also does not prohibit it), QUIC congestion control requires either pacing or some other burst limitation ({{Section 7.7 of RFC9002}}).  BBR congestion control implementations are common in QUIC stacks, and pacing is integral to BBR, so this document focuses on it.\r\n```\r\n\r\nAbout NewReno: 1) Yuchung keeps making the point that NewReno (as opposed to Reno) is just a difference in the recovery, not a \"new congestion control\", and I agree with him. I think it's called \"newreno\" as a choice in Linux, but let's keep RFCs clean and talk about Reno.  2) about \"not precluding\", I'm suggesting this change because else it might get confusing with other sections - e.g. Linux' pacing is applied to Reno.\r\n\r\nAbout the curly brackets: I learned this from one of the IESG reviews in TAPS, this actually works.",
              "createdAt": "2024-07-02T10:53:08Z",
              "updatedAt": "2024-07-02T11:00:54Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\nExamples of different approaches to dealing with these challenges in ways that work on multiple operating systems and hardware platforms can be found in open source QUIC stacks, such as Google \"quiche\" and Meta \"mvfst\", that provide examples for some of the concepts discussed below.\r\n```\r\n\r\nIMO, the sentence is a bit too long, and it's saying \"Examples can be found in... that provide examples for ...\" - please fil the double example thing somehow.",
              "createdAt": "2024-07-02T10:55:51Z",
              "updatedAt": "2024-07-02T11:00:54Z"
            },
            {
              "originalPosition": 62,
              "body": "```suggestion\r\nUnlike TCP implementations that typically run within the operating system kernel, QUIC implementations more typically run in user space and are thus faced with more challenges regarding timing and coupling with the underlying protocol stack and hardware needed to achieve pacing.  For instance, if an application trying to do pacing is running on a highly loaded system, it may often \"wake up late\" and miss the times that it intends to pace packets.\r\n```",
              "createdAt": "2024-07-02T10:56:22Z",
              "updatedAt": "2024-07-02T11:00:54Z"
            },
            {
              "originalPosition": 66,
              "body": "```suggestion\r\nPacing can be done based on different approaches such as a token-based or tokenless algorithm.  For instance, a tokenless algorithm might compute a regular interval time and batch size (number of packets) to be released every interval and achieve the pacing rate.  This allows specific future transmissions to be scheduled.  In contrast, a token-based algorithm accumulates tokens to permit transmission based on the pacing rate, using a \"leaky bucket\" to control bursts.  In this case the size of bursts may be more granular, depending on how much time is elapsed between evaluations.\r\n```",
              "createdAt": "2024-07-02T10:58:23Z",
              "updatedAt": "2024-07-02T11:00:54Z"
            },
            {
              "originalPosition": 66,
              "body": "Should \"time is elapsed\" be \"time has elapsed\"?  I don't know, you're the native speaker...",
              "createdAt": "2024-07-02T10:58:58Z",
              "updatedAt": "2024-07-02T11:00:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL2DqS86AidWX",
          "commit": {
            "abbreviatedOid": "2e71759"
          },
          "author": "wesley-eddy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-03T13:51:26Z",
          "updatedAt": "2024-07-03T13:51:26Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Yes this is good.  Just an odd thing to note: 9002 actually says \"NewReno\", but I agree with you (and Yuchung).",
              "createdAt": "2024-07-03T13:51:26Z",
              "updatedAt": "2024-07-03T13:51:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL2DqS86AiwKs",
          "commit": {
            "abbreviatedOid": "cbe957e"
          },
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-03T14:20:16Z",
          "updatedAt": "2024-07-03T14:20:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOL2DqS8572j6o",
      "title": "add Vidhi and Apple OS implementation detail",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/pull/10",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-09-18T06:19:41Z",
      "updatedAt": "2024-09-19T01:36:00Z",
      "baseRepository": "mwelzl/draft-iccrg-pacing",
      "baseRefName": "main",
      "baseRefOid": "6d788525374da73028d893bcb6b9b279a7c80b86",
      "headRepository": "goelvidhi/draft-iccrg-pacing",
      "headRefName": "dev/macos",
      "headRefOid": "77f62384e5a9bea760e4b13dedc859da9e76bb2d",
      "closedAt": "2024-09-19T01:36:00Z",
      "mergedAt": "2024-09-19T01:36:00Z",
      "mergedBy": "wesley-eddy",
      "mergeCommit": {
        "oid": "caa6f25409e9d19c77d9b7e08f3b08c1d6beffbc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOL2DqS86JzqCa",
          "commit": {
            "abbreviatedOid": "77f6238"
          },
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "This is great, thanks!",
          "createdAt": "2024-09-18T08:41:40Z",
          "updatedAt": "2024-09-18T08:41:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDOL2DqS85_Ina5",
      "title": "Initial FreeBSD text",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/pull/13",
      "state": "MERGED",
      "author": "tuexen",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-18T18:31:12Z",
      "updatedAt": "2024-10-21T10:24:17Z",
      "baseRepository": "mwelzl/draft-iccrg-pacing",
      "baseRefName": "main",
      "baseRefOid": "caa6f25409e9d19c77d9b7e08f3b08c1d6beffbc",
      "headRepository": "tuexen/draft-iccrg-pacing",
      "headRefName": "freebsd",
      "headRefOid": "4ce6625afba84ad2c464335871fc517c712f054f",
      "closedAt": "2024-10-20T13:07:02Z",
      "mergedAt": "2024-10-20T13:07:02Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "0657e0528bf8acada33454684688d47d67d346dc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOL2DqS86N4Yhi",
          "commit": {
            "abbreviatedOid": "9c3ae06"
          },
          "author": "mwelzl",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "This is a great start for sure, many thanks!  Just one tiny suggestion...",
          "createdAt": "2024-10-20T10:57:44Z",
          "updatedAt": "2024-10-20T10:58:09Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "```suggestion\r\nThe HPTS is optimized for handling a large number of TCP connections and the tcp_output() function of the RACK stack is also optimized for being called more often than the tcp_output() function of the default stack.\r\n```",
              "createdAt": "2024-10-20T10:57:44Z",
              "updatedAt": "2024-10-20T10:58:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL2DqS86N4ift",
          "commit": {
            "abbreviatedOid": "9c3ae06"
          },
          "author": "tuexen",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-20T11:52:59Z",
          "updatedAt": "2024-10-20T11:52:59Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "I push the corresponding fix.",
              "createdAt": "2024-10-20T11:52:59Z",
              "updatedAt": "2024-10-20T11:52:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOL2DqS85_TEFj",
      "title": "Beginning a change log",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/pull/14",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-21T10:30:04Z",
      "updatedAt": "2024-10-21T10:46:14Z",
      "baseRepository": "mwelzl/draft-iccrg-pacing",
      "baseRefName": "main",
      "baseRefOid": "0657e0528bf8acada33454684688d47d67d346dc",
      "headRepository": "mwelzl/draft-iccrg-pacing",
      "headRefName": "mw-changelog-01",
      "headRefOid": "20c017390951c5d6dcf5096b6bd7bad90f15ef6a",
      "closedAt": "2024-10-21T10:46:14Z",
      "mergedAt": "2024-10-21T10:46:14Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "12e8cdb7620b83807f21c1aab941b95ceb0253b7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 15,
      "id": "PR_kwDOL2DqS85_TEn9",
      "title": "Add me as a co-author",
      "url": "https://github.com/mwelzl/draft-iccrg-pacing/pull/15",
      "state": "MERGED",
      "author": "tuexen",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-21T10:31:01Z",
      "updatedAt": "2024-10-21T10:34:11Z",
      "baseRepository": "mwelzl/draft-iccrg-pacing",
      "baseRefName": "main",
      "baseRefOid": "0657e0528bf8acada33454684688d47d67d346dc",
      "headRepository": "tuexen/draft-iccrg-pacing",
      "headRefName": "coauthorship",
      "headRefOid": "626e6e9791ca5eb0a1b828baab0bf95dad3cb2bb",
      "closedAt": "2024-10-21T10:34:11Z",
      "mergedAt": "2024-10-21T10:34:11Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "97034f4f9bff49a4d1ce13ee521bb6ec055f9107"
      },
      "comments": [],
      "reviews": []
    }
  ]
}